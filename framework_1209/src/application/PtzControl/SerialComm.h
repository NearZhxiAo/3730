//////////////////////////////////////////////////////////////////////////  
/// COPYRIGHT NOTICE  
/// Copyright (c) 2009, xidian university（版权声明）  
/// All rights reserved.  
///   
/// @file    SerialComm.h    
/// @brief   串口通信类头文件  
///  
/// 本文件完成串口通信类的声明  
///  
/// @version 1.0     
/// @author  hzc	  
/// @E-mail：zhengchuanhu@gmail.com  
/// @date    2011/11/10
///  
///  修订说明：  
//////////////////////////////////////////////////////////////////////////  
#ifndef SERIALCOMM_H_
#define SERIALCOMM_H_

#include <Windows.h>
/*串口通信类
*本类实现了对串口的基本操作
*
*/
#define GET_DATA_MSG WM_USER+1

class CSerialComm
{
public:
	CSerialComm(void);
	~CSerialComm(void);
public:
	/** 初始化串口函数
	*  @param:  UINT portNo 串口编号,默认值为1,即COM1,注意,尽量不要大于9  
	*  @param:  UINT baud   波特率,默认为9600  
	*  @param:  char parity 是否进行奇偶校验,'Y'表示需要奇偶校验,'N'表示不需要奇偶校验  
	*  @param:  UINT databits 数据位的个数,默认值为8个数据位  
	*  @param:  UINT stopsbits 停止位使用格式,默认值为1  
	*  @param:  DWORD dwCommEvents 默认为EV_RXCHAR,即只要收发任意一个字符,则产生一个事件  
	*  @return: bool  初始化是否成功  
	*  @note:   在使用其他本类提供的函数前,请先调用本函数进行串口的初始化  
	*　　　　　   \n本函数提供了一些常用的串口参数设置,若需要自行设置详细的DCB参数,可使用重载函数  
	*           \n本串口类析构时会自动关闭串口,无需额外执行关闭串口 
	*
	*/
	bool InitSerialPort(UINT portNo = 1, UINT baud = CBR_9600, char parity = 'N', UINT databits = 8, 
				UINT stopsbits = 1, DWORD dwCommEvents = EV_RXCHAR);
	/** 串口初始化函数  
     *  
     *  本函数提供直接根据DCB参数设置串口参数  
     *  @param:  UINT portNo  
     *  @param:  const LPDCB & plDCB  
     *  @return: bool  初始化是否成功  
     *  @note:   本函数提供用户自定义地串口初始化参数  
     *  @see:      
     */ 
	bool InitSerialPort(UINT protNo, const LPDCB & plDCB);
	/** 开启监听线程  
     *  
     *  本监听线程完成对串口数据的监听,并将接收到的数据打印到屏幕输出  
     *  @return: bool  操作是否成功  
     *  @note:   当线程已经处于开启状态时,返回flase  
     *  @see:      
     */ 
//	bool OpenListenThread();
	 /** 关闭监听线程  
     *  
     *    
     *  @return: bool  操作是否成功  
     *  @note:   调用本函数后,监听串口的线程将会被关闭  
     *  @see:      
     */ 
	bool WriteData(unsigned char* pData,unsigned int lenght);
	/** 获取串口缓冲区中的字节数  
     *  
     *    
     *  @return: UINT  操作是否成功  
     *  @note:   当串口缓冲区中无数据时,返回0  
     *  @see:      
     */ 
	UINT GetBytesInSerialCom();
	 /** 读取串口接收缓冲区中一个字节的数据  
     *  
     *    
     *  @param:  char & cRecved 存放读取数据的字符变量  
     *  @return: bool  读取是否成功  
     *  @note:     
     *  @see:      
     */ 
//	bool ReadChar(char &cRecved);
	/************************************************************************/
	/* 关闭ListenThread()线程
	/* @param: 
	/* @note:
	/* @see
	/************************************************************************/
//	bool CloseListenThread();
	/************************************************************************/
	/* 判断端口是否正常打开
	/* @param: 
	/* @note:
	/* @see
	/************************************************************************/
	bool isPortWorking();
	/** 关闭串口  
     *  
     *    
     *  @return: bool  操作是否成功  
     *  @note:     
     *  @see:      
     */ 
	bool CloseSerialPort();
public:
	/** 打开串口  
     *  
     *    
     *  @param:  UINT portNo 串口设备号  
     *  @return: bool  打开是否成功  
     *  @note:     
     *  @see:      
     */ 
	bool openPort(UINT portNo);
	/** 关闭串口  
     *  
     *    
     *  @return: void  操作是否成功  
     *  @note:     
     *  @see:      
     */ 
	void closePort();
	/** 串口监听线程  
     *  
     *  监听来自串口的数据和信息  
     *  @param:  void * pParam 线程参数  
     *  @return: UINT WINAPI 线程返回值  
     *  @note:     
     *  @see:      
     */ 
//	static UINT WINAPI ListenThread(void *param);
	/* 关闭串口监听线程
	*
	*/
	

private:
	/* 串口句柄*/
	HANDLE m_hSerialComm;
	/* 线程退出标志变量*/
//	static bool s_bExit;
	/*线程句柄*/
//	volatile HANDLE m_hListenThread;
	/*同步互斥，临界区保护*/
	CRITICAL_SECTION m_csCommunicationSync;
	/*关于串口的信息*/
	OVERLAPPED m_osWrite;	
//	OVERLAPPED m_osRead,m_osWrite;	
};
#endif